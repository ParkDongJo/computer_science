 RED BLACK TREE 
 =====
 #####[INTRO]
  BST(이진검색트리)가 밸런스 붕괴가 되었을 시, 검색이 느려지는 한계점을 보완하기 위해, AVL 트리가
  고안되었다. 하지만 AVL트리는 만들기가 까다롭고 디버깅이 어렵다 또한 1이하의 높이를 유지하기 위하여,
  회전을 하는 비용이 높다.
   이러한 측면에서 더 개선된 트리가 바로 RED-BLACK 트리이다. 그러나 물론 RED-BLACK 트리도 만들기 쉽지가 않고,
  까다로운 건 마찬가지이다. 그럼에도 불구하고 AVL트리에 비해 더 낮은 회전 비용을 든다.
  
  
  
  [이론 흐름]<br>
 RED-BLACK TREE는  2-3-4 TREE와 같이 자주 언급된다. 2-3-4 tree는 구조를 이진트리에서 발전시켜, 부모노드에 무조건 2개의 자식노드가
 있어야 하는 규칙을 따르지 않는다. 그로 인해, 트리의 회전을 AVL 트리보다 손 쉽게 할 수 있다.(상대적으로) 하지만 트리의 구조가 복잡하다.(BST에 비해 자식 노다가 4개까지 될 수 있기 때문)
 
 여기서 레드-블랙 트리는 3차 B-트리인 2-3-4 트리의 밸런싱을 참고하여 이진트리로 표현한 것이다.
 2-3-4 트리는 B-Tree의 전신으로 3차 B-Tree와 동일한 구조를 가진다. 이를 BST에 옮겨 담았다.
   
 
 [레드-블랙 참고 강의](http://ddmix.blogspot.kr/2015/02/cppalgo-19-red-black-tree.html)
 
 [2-3-4 트리 wiki](https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree)
 
 [2-3-4 vs red-black pdf](http://faculty.simpson.edu/lydia.sinapova/www/cmsc250/LN250_Levitin/PDF/L09-RedBlackTrees.pdf)
 
 ***장점***
 - 레드-블랙 트리는 자료의 **삽입**과 **삭제**, **검색**에서 최악의 경우에도 일정한 실행 시간을 보장한다(worst-case guarantees).
 
 >> [레드 블랙 트리가 일정 속도를 갖는 이유]
 레드블랙 트리는 가장 균형이 깨졌을 때(= 속도가 가증 느릴 때)가 가장 짧은 노드연결의 길이와 가장 긴 노드 연결의 길이가 커봤자 2배이다. 이는 균형 잡힌 트리가 logN 에 수렴하고
 이에 2*log N 한다 하더라도 2를 상수로 취급하고 log N으로 봐도 무방하다.
  레드블렉 트리는 AVL트리에 비해 삽입,삭제에서 높은 성능을 보인다. 레드 블랙트리가 가장 성능이 나쁘게 나타나는 케이스는 삽입의 입장에서든, 삭제의 입장에서든
 컬리링 작업을 할 때 가장 낮은 성능을 보일 수 있다. 컬리링이 루트 노드까지 타고 갔을 시, logN의 성능을 보인다. 이는 가장 최악의 경우에도 삽입과
 삭제가 logN의 성능을 보일 수 있는 이유이다. 
 
 
 - AVL 트리는 레드-블랙 트리보다 더 엄격하게 균형이 잡혀 있기 때문에, 삽입과 삭제를 할 때 최악의 경우에는 더 많은 회전(rotations)이 필요하다

 >> AVL트리보다 레드블랙 트리가 더 선호되는 이유이다.

 ***단점***

 ***AVL Tree vs Red-Black Tree***

 [For small data] :

| 기능 | AVL TREE | RED-BLACK TREE |
| --- | --- | --- |
| insert | X | 더 효율적이다 |
| searck | 더 빠르다 | X |
| delete |X | 더 효율적이다 |
 

 [For large data] :
 
| AVL TREE | RED-BLACK TREE |
| --- | --- |
| insert | 더 빠르다 | X |
| search | 더 빠르다 | X |
| delete | X | 더 효율적이다 |

 > 여기서 더 효율적이라는 평가는 AVL 트리에 비해 RED-BLACK 트리는 최악의 경우에도 log(n)이라는 성능을 유지하기 때문이다.
   이는 AVL 트리가 상대적으로 빠른 성능을 낼 수 있다 하더라도(AVL 트리는 최대 1의 깊이 차이를 유지 하기 때문) 최악의 경우가 RED-BLACK 트리 보다
   안좋은 경우를 고려해서 내린 판단이라고 본다.
 
 [stackofflow에 DU Jiaen라는 개발자 답글](https://stackoverflow.com/questions/16257761/difference-between-red-black-trees-and-avl-trees)


 ***규칙***<br>
 레드-블랙 트리는 각각의 노드가 레드 나 블랙 인 색상 속성을 가지고 있는 이진 탐색 트리이다. 이진 탐색 트리가 가지고 있는 일반적인 조건에 다음과 같은
 추가적인 조건을 만족해야 유효한(valid) 레드-블랙 트리가 된다
 
 [참고자료 PDF자료](http://faculty.simpson.edu/lydia.sinapova/www/cmsc250/LN250_Levitin/PDF/L09-RedBlackTrees.pdf)
 
 
  **레트블랙 트리의 예시 이미지**
  ![레드블렉 트리의 예](https://hue9010.github.io/images/algorithm/red_black_tree_example.png)
 
 [RED-BLACK TREE 규칙들]
 
 1. 노드는 레드 혹은 블랙 중의 하나이다.
 2. 루트 노드는 블랙이다.
 3. 새로 들어오는 노드는 무조건 빨간색이다.
 3. 모든 리프 노드는 블랙이다.
 4. 레드 노드의 자식노드 양쪽은 언제나 모두 블랙이다. (즉, 레드 노드는 연달아 나타날 수 없으며, 블랙 노드만이 레드 노드의 부모 노드가 될 수 있다)
 5. 어떤 노드로부터 시작되어 리프 노드에 도달하는 모든 경로에는 리프 노드를 제외하면 모두 같은 개수의 블랙 노드가 있다.
 
 좀더 상세히 특징을 나열해 보자면
 
 [RED-BLACK TREE 상세 규칙]
 1. 각 노드는 하나의 키(key), 왼쪽자식(left), 오른쪽 자식(right), 그리고 부모노드(p)의 주소를 저장
 2. 자식노드가 존재하지 않을 경우 NIL 노드라고 부르는 특수한 노드가 있다고 가정, 따라서 모든 리프노드는 NIL노드
 3. 노드들은 내부노드와 NIL노드로 분류
 4. 실제 레드블랙 트리에서 NIL노드를 구현하진 않는다. 설명을 쉽게 하기 위한 용도
 5. 루트노드 위에도 NIL노드가 있다고 가정
 
 
  위의 규칙들로 인하여 RED-BLACK-TREE는 루트 노드부터 가장 먼 경로까지의 거리가, 가장 가까운 경로까지의 거리의 두 배 보다 항상 작다
 <br>
  다시 말해서 레드-블랙 트리는 개략적(roughly)으로 균형이 잡혀 있다(balanced). 따라서, 삽입, 삭제, 검색시 최악의 경우(worst-case)에서의 
 시간복잡도가 트리의 높이(또는 깊이)에 따라 결정되기 때문에 보통의 이진 탐색 트리에 비해 효율적이라고 할 수 있다.
 <br>
  왜 이런 특성을 가지는지 설명하기 위해서는, 네 번째 속성에 따라서, 어떤 경로에도 레드 노드가 연이어 나타날 수 없다는 것만 알고 있어도 충분하다.
 최단 경로는 모두 블랙 노드로만 구성되어 있다고 했을 때, 최장 경로는 블랙 노드와 레드 노드가 번갈아 나오는 것이 될 것이다. 다섯 번째 속성에 따라서, 
 모든 경로에서 블랙 노드의 수가 같다고 했기 때문에 존재하는 모든 경로에 대해 최장 경로의 거리는 최단 경로의 거리의 두배 이상이 될 수 없다.
 
 
 
 <br>

####레드 블랙 트리
 
***@ 레드블랙트리의 회전***

레드 블랙 트리에서 사용되는 회전 개념은 보통 자동차 핸들을 돌린다고 생각하면 된다.

    - 우회전 : 좌측에 있던 자식 노드를 부모 노드로 변경한 뒤, 왼쪽 자식노드의 오른쪽 자식 노드를
    부모의 왼쪽 자식으로 연결한다.
    
    - 좌회전 : 우측에 있던 자식노드를 부모 노드로 변경한 뒤, 오른쪽 자식노드의 왼쪽 자식 노드를 부모의
    오른쪽 자식으로 연결한다.
    

삽입 시 레드노드가 연속적으로 배치된 것을 없애기 위한 방법이 바로 위에서 배운 회전이다.
상황은 3가지로 나뉠 수 있다.

***@ 레드블랙트리의 균형***
 
1. 삼촌 노드가 빨간색인 경우

- 부모노드와 삼촌노드를 검은색으로 칠하고 할아버지 노드를 빨간색으로 칠한다.

- 할아버지 노드를 삽입한 노드로 생각하고 위의 과정을 루트까지 되풀이 한다.

2. 삼촌노드는 검은색이며 삽입한 노드가 부모의 오른쪽 자식인 경우

- 부모를 기준으로 좌회전

- 부모였던 노드를 삽입한 노드로 생각하고 문제를 3번으로 넘김

3. 삼촌노드는 검은색이며 삽입한 노드가 부모 왼쪽 자식인 경우
 
- 부모노드를 검은색 할아버지노드를 빨간색으로 칠한 후, 할아버지 노드를 우회전한다. 
 
 
 

 
 
 <레드 블랙 트리 원리><br>
 [레드 블랙 트리 참고(영문)](https://www.geeksforgeeks.org/red-black-tree-set-2-insert/)
 [레드 블랙트리 PDF](http://www.anyang.ac.kr/AYU_web/upload/ch05_%EA%B2%80%EC%83%89%ED%8A%B8%EB%A6%AC.pdf)
 [레드 블랙트리 삽입](http://thesoul214.tistory.com/113)
 [참고 코드,원리 블로그 링크](http://smile2x.tistory.com/entry/%E3%85%81%E3%85%81)
 [레드 블랙 트리 wiki 한글](https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC)
 
 