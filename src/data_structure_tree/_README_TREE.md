 TREE 
 =====
 #####[INTRO]
  트리 구조란 그래프의 일종으로, 여러 노드가 한 노드를 가리킬 수 없는 구조이다.
 간단하게는 회로가 없고, 서로 다른 두 노드를 잇는 길이 하나뿐인 그래프를 트리라고 부른다.
 
  트리에서 최상위 노드를 루트 노드(root node)라고 한다. 또한 노드 A가 노드 B를 가리킬 때
 A를 B의 부모 노드(parent node), B를 A의 자식 노드(child node)라고 한다. 자식 노드가
 없는 노드를 잎 노드(leaf node)라고 한다. 잎 노드가 아닌 노드를 내부 노드(internal node)라고 한다.
 
 [트리란]
 1) 비선형자로구조 : 데이터의 관계를 나타내는 것에 비중이 큼
 2) 뿌리에서 가지를 뻗어나가는 형태의 자료구조 : 계층을 나타냄
 
 [트리 관련 개념]
 1) 노드 : 트리 구성요소
 2) 엣지 : 노드와 노드를 연결하는 선
 3) 루트노드 : 트리구조에서의 최상위노드(서브트리도 포함, 어떤 트리가 문제해결의 중심이냐에 따라)
 4) 단말노드 : 아래로 다른 노드와의 연결없는 노드
 5) 내부노드 : 단말노드를 제외한 노드, 관계가 있는 노드
 6) 레벨 : 같은 높이에 있는 노드들
 7) 높이 : 루트노드(0)를 기준으로 가지가 총 몇단계에 걸쳐 뻗어져있는가?, 최대 레벨은 높이와 같음
 8) 서브트리 : 루트노드에서 뻗어져나온 노트들이 또 뻗었을 때 그때 트리 형태
 9) 형제관계 : 같은 레벨의 노드
 10) 부모관계
 11) 포화이진트리 : 모든 레벨에 꽉찬 이진트리
 12) 완전이진트리 : 차곡차곡 쌓여진 이진트리(포화이진트리X), 아래에서 위, 왼쪽에서 오른쪽
 
 
#### 순회
트리는 각각의 노드들이 부모,자식 관계로 맺어져 있기 때문에, 특정 노드를 삭제하고자 할 시 자식 노드가
있는 경우라면 삭제될 노드의 자식노드들은 메모리 누수가 되기 때문에 문제가 된다.
또한, 트리는 비선형 구조이기 때문에, 각각 노드들의 관계를 통해 데이터의 구조를 관리할 필요가 있다.
이때 순회를 이용하여, 노드의 각각 위치를 파악하고 재정비를 할 수 있다. 순회는 3가지 종류가 있으며,
기본적으로 재귀 함수를 사용한다.

    - 전위 순위
    1. Root 를 방문한다
    
    2. 왼쪽 subtree를 방문한다
    
    3. 오른쪽 subtree 를 방문한다
    
    특징> : 루트가 가장 먼저 나온다
    
    - 중위 순위
    1. 왼쪽 Subtree 를 방문한다
    
    2. Root 를 방문한다.
    
    3. 오른쪽
    
    특징> : 가장 왼쪽노드가 먼저 나온다
    
    - 후위 순위
    1. 왼쪽 subtree 를 방문한다.

    2. 오른쪽 subtree 를 방문한다.

    3. root 를 방문한다

    특징>

    1. 가장 왼쪽 노드가 첫번째 나온다

    2.루트가 가장 나중에 나온다


#### 트리의 종류
- 이진트리
- 이진 탐색 트리(BST), 자가균형 이진 탐색트리

    이진 트리의 일종으로, 노드의 왼쪽 가지에는 노드의 값보다 작은 값들만 있고, 오른쪽 가지에는 큰 값들만 있도록 구성되었다. 자식 노드들도 동일한 방법으로 정렬되어 노드의 왼쪽 자식의 왼쪽 가지에는 왼쪽 자식이 가진 값보다 작은 값만 있고, 왼쪽 자식의 오른쪽 가지에는 왼쪽 자식의 값보다 큰 값들만 있고, 오른쪽 자식의 왼쪽 가지에는... 이런 식으로 이진 탐색 트리의 어느 노드를 잡아도 동일한 규칙으로 정렬이 되어 있다.
    
    이렇게 구성해 두면 어떤 값 n을 찾을 때, 루트 노드와 비교해서 n이 더 작다면 루트 노드보다 큰 값들만 모여 있는 오른쪽 가지는 전혀 탐색할 필요가 없다. 마찬가지로 루트 노드의 왼쪽 자식보다 n이 크다면 왼쪽 자식의 왼쪽 가지는 탐색할 필요가 없고... 다시 말해 트리 자체가 이진 탐색을 하기에 적합한 구성이 되는 것이다. 또한 값을 찾을 때 뿐만이 아니라 값을 삽입하거나 삭제할 때도 똑같은 과정을 거치므로, 이상적인 상황에서 탐색/삽입/삭제 모두 시간복잡도가 O(log N)이 된다.
    
    다만 단점이 있는데, 값이 삽입되거나 삭제되는 경우에 따라서 운이 안좋으면 최악의 경우에 O(N)의 시간이 걸리게 된다. 예를 들어, 비어있는 이진 탐색 트리에 1부터 100까지 순서대로 삽입한다면 처음 루트 노드는 1이 되고, 2는 1보다 크니 1의 오른쪽 자식이 되고, 3은 1보다 크니 1의 오른쪽, 2보다 크니 2의 오른쪽... 이런 식으로 트리의 오른쪽 끝으로만 계속 성장하게 된다. 이 상태로 50을 찾는다고 하면 결국 1부터 순서대로 오른쪽으로 쭈욱 내려가는 선형 탐색이나 다를게 없게 된다. 이러한 경우를 트리가 편향(skew)되었다고 한다.

- AVL 트리

    가장 처음으로 나온 자가 균형 이진 탐색 트리로, 이진 탐색 트리가 운이 안 좋을 경우 O(N)의 시간이 걸리는 것을 보완한 트리이다.이상적인 상황에서나 최악의 상황에서 탐색/삽입/삭제 모두 시간 복잡도가 O(log N)이다. 만족해야 하는 조건은 모든 노드에서 오른쪽 트리와 왼쪽 트리의 높이(height)의 차이가 1이하로만 나는것. 삽입/삭제를 할 때마다 균형이 안맞는 것을 맞추기 위해 트리의 일부를 왼쪽 혹은 오른쪽으로 회전시켜야 한다. 
    균형은 아래에 나온 Red-black tree보다 훨씬 잘 잡히지만, 그렇기 때문에 Red-black tree보다 삽입과 제거가 느리고 탐색 자체는 빠르다. 그래서 보통 자가 균형 이진 탐색 트리가 필요한 경우 Red-black tree를 쓰는 경우가 많다.

- 레드-블랙 트리
- 신장 트리, 최소 비용 신장 트리
- B-트리, 2-3 트리, B+ 트리, B*-트리

