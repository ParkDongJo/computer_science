시간 복잡도 
 =====
 #####[INTRO]
 ###TIME COMPLEX(시간복잡도)?
  단순히 시간복잡도를 연산의 속도라고 볼 수 있다. 하지만, 연산의 속도는 너무 포괄적이다.
  하나의 프로그램이 실행되기까지, 메모리 상 실행파일 > 컴파일 > 링커 > CPU 연산 까지 너무 포괄적이다.
  
   그렇다면 알고리즘에서 시간복잡도는 무엇일까 
  본론부터 말하면, 시간복잡도란 알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것이다.
  여기서 핵심은 **입력 크기**에 대한 함수라는 점이다.
    
   임의 특정 함수가 있고 이 함수의 시간복잡도가 몇이냐라고 했을 때, 해당 함수의 입력되는 데이터의 크기 어느정도이냐에 따라서 다를 수 있다.
  이는 효율적인 알고리즘이냐 아니냐를 판가름 하는 척도가 된다.
  
  ####시간복잡도 의 종류
  
  - 세터표기법 : 임의의 두 상수 i(최상),j(최하) / 임의의 함수 f()라고 했을 때, 
                i*f()와 j*f()의 사이에 있는 k*f() 함수를 나타낸다
                가장 정확한 표기법이라고 할 수 있다.
                
  - 빅오표기법 : 최악의 시나리오를 염두해 두고 판단하는 시간복잡도 측정법이다.
                '이보다 모든 경우가 좋다!!'로 보는 시각이다.
              그렇기 때문에 이런 등식이 성립한다.
               
               >> O(n) == O(n^2)
               
               O(n^2)이 O(n)보다 훨신 최악의 상황이다. 결국 O(n)은 O(n^2)에 포함이 된다.
               
  - 옴표기법 : 최고의 시나리오를 염두해 두고 판단하는 시간복잡도 측정법이다. '이보다 더 나쁠 순 없다'로 보는 시각이다.
  
  
  예시를 하나 들어보자
  
  **예제1 >**
  임의 정렬코드의 시간복잡도 -> n^2 + 1000n + 100000
  
  1) 세터표기법 > θ(n^2)
  2) 빅오표기법 > O(n^2)
  3) 옴표기법 > Ω(n^2)
  
  
  **예제2 >**
  이진트리 검색의 시간복잡도 -> log n
  
  1) 세터표기법 > 표기 불가!! - 구할 수가 없음(두가지의 함수를 가지는 경우)
  2) 빅오표기법 > O(n)
  3) 옴표기법 > Ω(1)
  
  
  ####크기 순서
  O(1) <
  O(log n) <
  O(root n) <
  O(n) <
  O(n^2) <
  O(C^n) <
  O(!n) <